---
title: 【代码】找树问题
categories:
  - Java
date: 2020-09-08 14:33:13
---

## 前言

小伙伴给我发来消息叫我帮他做一道编程题，于是我用最擅长的java解决了问题。
由于时间原因，只做了控制台打印的简单程序，没有做带UI界面的程序

<!-- more -->

## 问题

![01.png](/images/20200908143313/01.png)

## 程序使用讲解

- 通过输入坐标点判定是否最终能找到树，如果程序执行了999次也没找到树，就直接返回没找到
- 可以将列表比作数学中的平面直角坐标系，原点在左下位置，左下角坐标点为`(1,1)`，右上角坐标点为`(5,5)`

![02.png](/images/20200908143313/02.png)

## 源代码

``` java
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class Application {

    // 定义一个map用于存放所有坐标及其对应的内容
    static Map<String,String> map = new HashMap<>();

    // 定义初始化方法，将坐标赋值为map的key，将它表示的内容赋值为map的value，并把value打印到控制台
    public static void view() {

        // 为第一列赋值
        map.put("(1,1)", "4U");map.put("(1,2)", "2R");map.put("(1,3)", "2R");map.put("(1,4)", "2D");map.put("(1,5)", "2D");

        // 为第二列赋值
        map.put("(2,1)", "3U");map.put("(2,2)", "1U");map.put("(2,3)", "2U");map.put("(2,4)", "1R");map.put("(2,5)", "2R");

        // 为第三列赋值
        map.put("(3,1)", "2L");map.put("(3,2)", "2R");map.put("(3,3)", "0");map.put("(3,4)", "2R");map.put("(3,5)", "4D");

        // 为第四列赋值
        map.put("(4,1)", "2L");map.put("(4,2)", "2L");map.put("(4,3)", "2D");map.put("(4,4)", "3L");map.put("(4,5)", "1D");

        // 为第五列赋值
        map.put("(5,1)", "4U");map.put("(5,2)", "1U");map.put("(5,3)", "1L");map.put("(5,4)", "3D");map.put("(5,5)", "2L");

        // 将五行数据打印到控制台
        System.out.println(map.get("(1,5)")+"\t"+map.get("(2,5)")+"\t"+map.get("(3,5)")+"\t"+map.get("(4,5)")+"\t"+map.get("(5,5)"));
        System.out.println(map.get("(1,4)")+"\t"+map.get("(2,4)")+"\t"+map.get("(3,4)")+"\t"+map.get("(4,4)")+"\t"+map.get("(5,4)"));
        System.out.println(map.get("(1,3)")+"\t"+map.get("(2,3)")+"\t"+map.get("(3,3)")+"\t"+map.get("(4,3)")+"\t"+map.get("(5,3)"));
        System.out.println(map.get("(1,2)")+"\t"+map.get("(2,2)")+"\t"+map.get("(3,2)")+"\t"+map.get("(4,2)")+"\t"+map.get("(5,2)"));
        System.out.println(map.get("(1,1)")+"\t"+map.get("(2,1)")+"\t"+map.get("(3,1)")+"\t"+map.get("(4,1)")+"\t"+map.get("(5,1)"));


    }

    public static void main(String[] args) {
        // 程序无限循环
        while(true) {

            // 初始化
            view();

            // 提示
            System.out.println("请指定起始坐标");
            System.out.println("示例：(1,2)");
            System.out.print("> ");

            // 向控制台输入一个坐标
            Scanner sc = new Scanner(System.in);
            String point = sc.next();
            String begin = point;


            // 设置一个开关，当找到树，则改变开关为true
            boolean key = false;

            // 执行999次，如果还是找不到就跳出循环
            for(int i = 0; i < 999; i++) {

                // 打印经过的坐标点（方便调试）
                System.out.println("调试："+point);

                // 判断当前坐标点是不是树
                // 如果是，改变开关状态并强制退出循环
                if(map.get(point).equals("0")) {
                    key = true;
                    break;
                }

                // 获取当前坐标点的value，并拆分，分别表示下一次前进的次数和前进的方向
                int before = Integer.parseInt(map.get(point).charAt(0)+"");
                String after = map.get(point).charAt(1)+"";

                // 根据次数和方向向前前进，前进后进行下一次循环
                if (after.equals("U")) {
                        point = goUp(point,before);
                } else if (after.equals("D")) {
                        point = goDown(point,before);
                } else if (after.equals("L")) {
                        point = goLeft(point,before);
                } else if (after.equals("R")) {
                        point = goRight(point,before);
                }

            }

            // 根据开关状态，将结果打印
            System.out.println("======");
            if(key) {
                System.out.println("找树成功");
                System.out.println("当前起始值为："+begin);
            } else {
                System.out.println("找树失败");
            }
            System.out.println("======");

            // 为了能看清结果再进行下一次程序执行，在此处做一个暂停的操作
            System.out.println("输入任意值继续...");
            String p = sc.next();

        }
    }

 // 设定四种方法，功能分别是向上、向下、向左、向右移动
    public static String goUp(String c, int n) {
        // 拆分字符串，分别提取横坐标和纵坐标
        int row = Integer.parseInt(c.charAt(1)+"");
        int col = Integer.parseInt(c.charAt(3)+"");
        // 根据传过来的原坐标和前进的此处，重新定义新坐标并替换为原坐标
        for (int i = 0; i < n; i++) {
            col++;
        }
        // 将横纵坐标重新定义为坐标格式返回给方法调用者
        return "("+row+","+col+")";
    }
    public static String goDown(String c, int n) {
        int row = Integer.parseInt(c.charAt(1)+"");
        int col = Integer.parseInt(c.charAt(3)+"");
        for (int i = 0; i < n; i++) {
            col--;
        }
        return "("+row+","+col+")";
    }
    public static String goLeft(String c, int n) {
        int row = Integer.parseInt(c.charAt(1)+"");
        int col = Integer.parseInt(c.charAt(3)+"");
        for (int i = 0; i < n; i++) {
            row--;
        }
        return "("+row+","+col+")";
    }
    public static String goRight(String c, int n) {
        int row = Integer.parseInt(c.charAt(1)+"");
        int col = Integer.parseInt(c.charAt(3)+"");
        for (int i = 0; i < n; i++) {
            row++;
        }
        return "("+row+","+col+")";
    }

}
```

## 完成

